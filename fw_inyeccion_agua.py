# -*- coding: utf-8 -*-
"""FW_inyeccion_agua.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1M-oQ1FN-SRxncVAcHd4IDaGYTKKMHBwP

# **RENDIMIENTO DE INYECCIÓN DE AGUA**

*BY: JOAO UGALDE, ANTHONY CHALÁ*
"""

import numpy as np
from datetime import datetime
import matplotlib.pyplot as plt
from scipy import interpolate
import pandas as pd
from tabulate import tabulate
from prettytable import PrettyTable

###########################################################################################################################################################

#NOTA: Para realizar los cálculos se considera que Swi=Swc=Swirr
opcion1=0

while True:
    print("Rendimiento de inyección de agua")
    print("1. Calcular con datos default")
    print("2. Ingresar datos")
    print("3. Salir")

    opcion = input("Selecciona una opción: ")

    if opcion == '1':
        # Cálculos con datos default
        Sw = np.array([0.25, 0.30, 0.35, 0.40, 0.45, 0.50, 0.55, 0.60, 0.65, 0.70, 0.75])
        #krw = np.array([0, 0.003, 0.01, 0.02, 0.045, 0.085, 0.14, 0.2, 0.27, 0.33])
        #kro = np.array([1, 0.89, 0.71, 0.56, 0.42, 0.3, 0.195, 0.1, 0.035, 0])
        krw = ["N/A"] * len(Sw)
        kro = ["N/A"] * len(Sw)
        kr_ow = np.array([30.23, 17.00, 9.56, 5.38, 3.02, 1.70, 0.96, 0.54, 0.30, 0.17, 0.10])
        Uw = 1 # centipoise
        Uo = 2  # centipoise
        Swi = 0.25 #fraccion
        Swc = Swi  #fraccion
        Swirr = Swi   #fraccion
        Area = 26400  #ft^2
        Long = 660   #ft
        phi = 0.25   #fraccion
        Bo = 1.25    #Bls/BN
        Bw = 1.02     #Bls/BN
        Qiw = 900    #Bls/día
        break
    elif opcion == '2':
        n = -1
        while n <= 0:
            try:
                n = int(input("¿Cuántos datos de Sw va a ingresar: "))
                if n <= 0:
                    print("Por favor, ingresa un número positivo.")
            except ValueError:
                print("Por favor, ingresa un valor numérico válido.")

        # Inicializar un array y agregar elementos ingresados por el usuario
        Sw = []
        kro = []
        krw = []
        kr_ow = []

        for i in range(n):
            elemento = -1
            while elemento < 0:
                try:
                    elemento = float(input(f"Ingrese el elemento {i + 1} de Sw: "))
                    if elemento < 0:
                        print("Por favor, ingresa un número mayor o igual a cero.")
                except ValueError:
                    print("Por favor, ingresa un valor numérico válido.")
            Sw.append(elemento)
        Sw = np.array(Sw)

        print("¿Qué desea ingresar?")
        print("1. Valores de krw y kro")
        print("2. Valores de kro/krw")
        opcion1 = input("Selecciona una opción: ")
        if opcion1 == '1':
          for i in range(n):
            elemento = -1
            while elemento < 0:
                try:
                    elemento = float(input(f"Ingrese el elemento {i + 1} de krw: "))
                    if elemento < 0:
                        print("Por favor, ingresa un número mayor o igual a cero.")
                except ValueError:
                    print("Por favor, ingresa un valor numérico válido.")
            krw.append(elemento)
          krw = np.array(krw)

          for i in range(n):
            elemento = -1
            while elemento < 0:
                try:
                    elemento = float(input(f"Ingrese el elemento {i + 1} de kro: "))
                    if elemento < 0:
                        print("Por favor, ingresa un número mayor o igual a cero.")
                except ValueError:
                    print("Por favor, ingresa un valor numérico válido.")
            kro.append(elemento)
          kro = np.array(kro)

        if opcion1 == '2':
          krw = ["N/A"] * n
          kro = ["N/A"] * n
          for i in range(n):
            elemento = -1
            while elemento < 0:
                try:
                    elemento = float(input(f"Ingrese el elemento {i + 1} de kro/krw: "))
                    if elemento < 0:
                        print("Por favor, ingresa un número mayor o igual a cero.")
                except ValueError:
                    print("Por favor, ingresa un valor numérico válido.")
            kr_ow.append(elemento)
          kr_ow = np.array(kr_ow)


        Uw = float(input("Viscosidad del agua (cp): "))
        Uo = float(input("Viscosidad del petróleo (cp): "))
        Swi = float(input("Saturación de agua inicial (fracción): "))
        Swc = Swi  #fraccion
        Swirr = Swi   #fraccion
        Area = float(input("Área (ft^2): "))
        Long = float(input("Longitud (ft): "))
        phi = float(input("Porosidad (fracción): "))
        Bo = float(input("Factor volumétrico del petróleo (Bls/BN): "))
        Bw = float(input("Factor volumétrico del agua (Bls/BN): "))
        Qiw = float(input("Tasa de inyección (Bls/día): "))
        break

    elif opcion == '3':
        print("Saliendo del programa.")
        break
    else:
        print("Opción no válida. Por favor, elige una opción válida.")

###########################################################################################################################################################

# Cálculo de Fw
if opcion1 == '1':
  for i, j in zip(krw, kro):
      if i != 0:
          kr_ow.append(j / i)
      else:
          kr_ow.append(0)
  fw = []
  for i, j in zip(krw, kro):
      if i != 0:
          fw.append(1 / (1 + (j / i) * (Uw / Uo)))
      else:
          fw.append(0)


if opcion1 == '2' or opcion == '1':
  fw = []
  for i in range(len(Sw)):
      if i != 0:
          fw.append(1 / (1 + (kr_ow[i]) * (Uw / Uo)))
      else:
          fw.append(0)


# Interpolar con splines
tck = interpolate.splrep(Sw, fw, s=0)
Sw_smooth = np.linspace(Sw.min(), Sw.max(), 1000)
fw_smooth = interpolate.splev(Sw_smooth, tck, der=0)

# Realizar regresión polinómica con un grado de 30
degree = 30
coefficients = np.polyfit(Sw_smooth, fw_smooth, deg=degree)
p = np.poly1d(coefficients)

# Calcular el R^2
mean_fw = np.mean(fw_smooth)
ss_total = np.sum((fw_smooth - mean_fw) ** 2)
ss_res = np.sum((fw_smooth - p(Sw_smooth)) ** 2)
r_squared = 1 - (ss_res / ss_total)

# Valores de Swx a evaluar
Swx = np.linspace(Swi+0.15, Sw[-1], 100)
# Evaluar los valores de Swx en la ecuación polinómica
fw_predicted = p(Swx)

# Calcular la pendiente máxima
m_values = []
for i in range(len(fw_predicted)):
    m = (fw_predicted[i] - fw[0]) / (Swx[i] - Swi)
    m_values.append(m)

m_values_np = np.array(m_values)
max_m = np.max(m_values_np)
index_max_m = np.argmax(m_values_np)

# Obtener el valor de max_m
max_m_value = m_values_np[index_max_m]

# Obtener los valores de fw_predicted y Swx que corresponden a max_m
fwf = fw_predicted[index_max_m]
Swf = Swx[index_max_m]

# Dibujar la recta tangente
x0 = Swi
y0 = 0
m = max_m

b = y0 - m * x0

def recta(x):
    return m * x + b

# Encontrar el valor de x cuando y = 1
y_target = 1
Swbf = (y_target - b) / m

x_vals = np.linspace(0, 1, 100)
y_vals = recta(x_vals)

##################### Despues del breakthrough #####################
Swx2=Sw
def primer_numero_mayor(array, valor):
    for i, numero in enumerate(array):
        if numero > valor:
            return numero, i
    return None, None

valor_buscar = Swf
resultado, posicion = primer_numero_mayor(Swx2, valor_buscar)

valor_buscar2 = Swx2[posicion]
resultado2, posicion2 = primer_numero_mayor(Swx, valor_buscar)

dfw_dSw = []
for i in range(len(Sw)):
  if i == 0:
    dfw_dSw.append(0)
  elif (Swx[posicion2+5] - Swx2[posicion]) != 0 and (Swx[posicion2+5] - Sw[posicion]) != 0:
    dfw_dSw.append((fw_predicted[posicion2+5] - fw[posicion]) / (Swx[posicion2+5] - Sw[posicion]))
  else:
    dfw_dSw.append(0)

Smw2=Sw[posicion]+((1-fw[posicion])/(dfw_dSw[1]))


# Dibujar la recta tangente posterior al breakthrough
x1 = Swx2[posicion]
y1 = fw[posicion]
m1 = dfw_dSw[posicion+1]

b1 = y1 - m1 * x1

def recta(x):
    return m1 * x + b1

# Encontrar el valor de x cuando y = 1
#y_target1 = 1
#Smw2 = (y_target1 - b1) / m1
x_vals1 = np.linspace(0, 1, 100)
y_vals1 = recta(x_vals1)

################################################################ Cálculos antes del breakthrough ####################################################
#Tiempo
Qibt=Swbf-Swi
tf=((phi*Area*Long*Qibt)/(5.615*Qiw))/30

#Agua inyectada acumulada
Wif=(phi*Area*Long*Qibt)/(5.615)

#Petróleo recuperado en el tiempo de ruptura
Npf=(phi*Area*Long*(Swf-Swi))/(5.615*Bo)

#Eficiencia de desplazamiento de barrido hasta la ruptura
EDbt=((Swbf-Swi)/(1-Swi))*100

#Agua producida hasta la ruptura
Swc=Swi
Swirr=Swi
Wpf=Area*phi*Long*(Swc-Swirr)

################################################################ Cálculos después del breakthrough ####################################################
#Tiempo
Qi2=(Smw2-Swx2[posicion])/(1-fw[posicion])
t2=((Area*phi*Long*Qi2)/(5.615*Qiw))/30

# Volumen poroso inyectado
#Qi2=(Smw2-Swx2[posicion])/(1-fw[posicion])

# Petróleo producido
Np=(Area*phi*Long*(Smw2-Swf))/(5.615*Bo)

# Agua inyectada acumulada
Wi2=(phi*Area*Long*Qi2)/5.615

# Agua producida
Wp=Wi2-(Np*Bo)

# Petróleo total antes y después de la ruptura
Npt=Npf+Np

# WOR
WOR=(Bo*fw[posicion])/((1-fw[posicion])*Bw)

###########################################################################################################################################################

print("*********************************** RESULTADOS ***********************************\n")
print("NOTA: Para realizar los cálculos se considera que Swi=Swc=Swirr\n")
print("Datos de entrada:")
#data = {'Sw': Sw, 'Kr_ow': kr_ow}
data = {'Sw': Sw, 'Kr_w': krw, 'kr_o': kro, 'Kr_ow': kr_ow}
df = pd.DataFrame(data)
data_in = tabulate(df, headers='keys', tablefmt='grid', showindex=False)
print(data_in)
data1 = {'Uo (cp)': [Uo], 'Uw (cp)': [Uw], 'Swi': [Swi], 'Area (ft^2)': [Area], 'Longitud (ft)': [Long], 'Porosidad (fracción)': [phi],
         'Bo (Bls/BN)': [Bo], 'Bw (Bls/BN)': [Bw], 'Qiw (Bls/dia)': [Qiw]}
df1 = pd.DataFrame(data1)
data_in1 = tabulate(df1, headers='keys', tablefmt='grid', showindex=False)
print(data_in1)

# Dibujo de la curva Sw vs fw y el ajuste polinómico
print("\nCurva de flujo fraccional")
f = plt.figure(figsize=(15, 5))
ax = f.add_subplot(121)
ax.plot(Sw_smooth, fw_smooth, 'b-', label='Curva Fw suavizada')
ax.scatter(Sw, fw, marker='o', color="black", s=20)
ax.plot(Sw_smooth, p(Sw_smooth), 'r--')
ax.plot([Swf, Swf, 0], [0, fwf, fwf], 'r--')
ax.plot([Swbf, Swbf], [0, 1], 'r--')
ax.plot([Smw2, Smw2], [0, 1], 'r--')
ax.annotate('(Swf={:.2f}; fwf={:.2f})'.format(Swf,fwf), (Swf, fwf))
ax.annotate('Swbf={:.2f}'.format(Swbf), (Swbf, 0))
ax.annotate('(Sw2={:.2f}; fw2={:.2f})'.format(Swx2[posicion],fw[posicion]), (Swx2[posicion], fw[posicion]))
ax.annotate('Smw2={:.2f}'.format(Smw2), (Smw2, 0.5))
ax.set_title('Curva de flujo fraccional')
ax.set_xlabel('$S_W$')
ax.set_ylabel('$f_W$')
ax.set_xlim(0, 1)
ax.set_ylim(0, 1)
ax.legend()
ax.plot(x_vals, y_vals)
ax.plot(x_vals1, y_vals1)
ax.grid(True)
plt.show()

print("\nDe la curva de flujo fraccional se obtiene:")
tabla1 = PrettyTable()
tabla1.field_names = ["Parámetros", "Valor"]
tabla1.add_row(["Flujo de agua en el frente de flujo (fwf)", fwf])
tabla1.add_row(["Saturación frente de inundación (Swf)", Swf])
tabla1.add_row(["Saturación de agua promedio al tiempo de ruptura (Swbf)", Swbf])
tabla1.add_row(["Saturación de agua inicial (Swi)", Swi])
tabla1.add_row(["Saturación de agua después de la ruptura (Sw2)", Swx2[posicion]])
tabla1.add_row(["Flujo de agua después de la ruptura (fw2)", fw[posicion]])
tabla1.add_row(["Saturación de agua promedio después de la ruptura (Smw2)", Smw2])
print(tabla1)

print("\nComportamiento hasta la ruptura:")
tabla2 = PrettyTable()
tabla2.field_names = ["Parámetros", "Valor", "Unidad"]
tabla2.add_row(["Tiempo (tf)", tf, "meses"])
tabla2.add_row(["Agua inyectada acumulada (Wif)", Wif, "Bls"])
tabla2.add_row(["Petróleo recuperado (Npf)", Npf, "BN"])
tabla2.add_row(["Eficiencia de desplazamiento de barrido (EDbt)", EDbt, "%"])
tabla2.add_row(["Agua producida (Wpf)", Wpf, "Bls"])
print(tabla2)

print("\nComportamiento después la ruptura:")
tabla3 = PrettyTable()
tabla3.field_names = ["Parámetros", "Valor", "Unidad"]
tabla3.add_row(["Tiempo (t')", t2, "meses"])
tabla3.add_row(["Volumen poroso de agua inyectado (Qi')", Qi2, " "])
tabla3.add_row(["Petróleo producido (ΔNp)", Np, "BN"])
tabla3.add_row(["Agua inyectada acumulada (Wi)", Wi2, "Bls"])
tabla3.add_row(["Agua producida (Wp')", Wp, "Bls"])
tabla3.add_row(["Petróleo producido antes y después de la ruptura (Npt')", Npt, "BN"])
tabla3.add_row(["Relación Agua-Petróleo (WOR)", WOR, " "])
print(tabla3)

###########################################################################################################################################################
#Grafica Produccion Incremental, con los datos default
print("\nGráficas con los datos default:")
# Lista de cadenas de fechas en formato dd/mm/yyyy
fechas_str = [
    "31/05/2018", "30/06/2018", "31/07/2018", "31/08/2018", "30/09/2018", "31/10/2018",
    "30/11/2018", "31/12/2018", "31/01/2019", "28/02/2019", "31/03/2019", "30/04/2019",
    "31/05/2019", "30/06/2019", "31/07/2019", "31/08/2019", "30/09/2019", "31/10/2019",
    "30/11/2019", "31/12/2019", "31/01/2020", "29/02/2020", "31/03/2020", "30/04/2020",
    "31/05/2020", "30/06/2020", "31/07/2020", "31/08/2020", "30/09/2020"
]

# Formato de fecha
formato_fecha = "%d/%m/%Y"

# Convertir las cadenas de fecha a objetos datetime y agregar al vector
Fecha = [datetime.strptime(fecha_str, formato_fecha).date() for fecha_str in fechas_str]

produccion_petroleo_s_proyecto = [240.00, 228.00, 216.00, 204.00, 193.00, 182.00, 172.00, 162.00, 154.00, 145.00,
    137.00, 130.00, 122.00, 116.00, 110.00, 104.00, 98.00, 93.00, 88.00, 83.00,
    78.00, 74.00, 70.00, 66.00, 62.00, 59.00, 56.00, 53.00, 50.00]

produccion_petroleo_c_proyecto = [1281.00, 1261.00, 1242.00, 1223.00, 1205.00, 182.00, 1173.00, 1158.00, 1143.00, 1130.00,
    1117.00, 1106.00, 1094.00, 1084.00, 1074.00, 1064.00, 1055.00, 1047.00, 1039.00, 1031.00,
    1024.00, 1017.00, 1011.00, 1005.00, 999.00, 994.00, 989.00, 984.00, 979.00]

produccion_agua_c_proyecto = [7757.00, 7769.00, 7779.00, 7789.00, 7798.00, 7806.00, 7813.00, 7820.00, 7825.00, 7830.00,
    7834.00, 7837.00, 7840.00, 7842.00, 7843.00, 7844.00, 7845.00, 7845.00, 7844.00, 7844.00,
    7842.00, 7841.00, 7839.00, 7836.00, 7833.00, 7831.00, 7827.00, 7824.00, 7820.00]


#Importar Data desde un archivo en excel
#data_produccion = pd.read_excel('/content/data_produccion.xlsx')
fig, ax=plt.subplots(figsize=(9,5))
ax.plot(Fecha, produccion_petroleo_s_proyecto, marker="o", label='Producción petróleo sin proyecto', color="tab:red")
ax.plot(Fecha, produccion_petroleo_c_proyecto, marker="o", label='Producción petróleo con proyecto', color="tab:blue")
ax.set_xlabel('Fecha (meses)')
ax.set_ylabel('Producción de petróleo (Bls/dia)')
ax.set_title('Producción Incremental')
ax.legend()
ax.grid(True)
plt.show

fig, ax=plt.subplots(figsize=(9,5))
ax.plot(Fecha, produccion_agua_c_proyecto, marker="o", label='Producción Agua con proyecto', color="tab:blue")
#ax.plot(data_produccion["Fecha"], data_produccion["Producción Agua sin proyecto"], marker="o", label='Producción Agua sin proyecto', color="tab:red")
ax.set_xlabel('Fecha (meses)')
ax.set_ylabel('Producción de Agua (Bls/dia)')
ax.set_title('Wp vs t')
ax.legend()
ax.grid(True)
plt.show